<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DFTK.jl: The density-functional toolkit. · DFTK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DFTK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>DFTK.jl: The density-functional toolkit.</a><ul class="internal"><li><a class="toctext" href="#Terminology-and-Definitions-1">Terminology and Definitions</a></li><li><a class="toctext" href="#Plane-wave-basis-functions-1">Plane wave basis functions</a></li><li><a class="toctext" href="#Basis-sets-1">Basis sets</a></li><li><a class="toctext" href="#Real-space-grids-1">Real-space grids</a></li><li><a class="toctext" href="#Core-1">Core</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DFTK.jl: The density-functional toolkit.</a></li></ul><a class="edit-page" href="https://github.com/mfherbst/DFTK.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DFTK.jl: The density-functional toolkit.</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DFTK.jl:-The-density-functional-toolkit.-1" href="#DFTK.jl:-The-density-functional-toolkit.-1">DFTK.jl: The density-functional toolkit.</a></h1><p>DFTK is a <code>julia</code> package of for playing with plane-wave density-functional theory algorithms.</p><h2><a class="nav-anchor" id="Terminology-and-Definitions-1" href="#Terminology-and-Definitions-1">Terminology and Definitions</a></h2><p>General terminology used throughout the documentation of the plane-wave aspects of the code.</p><h2><a class="nav-anchor" id="Plane-wave-basis-functions-1" href="#Plane-wave-basis-functions-1">Plane wave basis functions</a></h2><p>At the moment the code works exclusively with orthonormal plane waves. In other words our bases consist of functions</p><div>\[e_G = 1/\sqrt{\Omega} e^{i\, G \cdot x}\]</div><p>where <span>$\Omega$</span> is the unit cell volume.</p><h2><a class="nav-anchor" id="Basis-sets-1" href="#Basis-sets-1">Basis sets</a></h2><ul><li>The <strong>wave-function basis</strong> <span>$B_{Ψ,k}$</span> (used to be <span>$X_k$</span>), consisting of all plane-wave basis functions below the desired energy cutoff <span>$E_\text{cut}$</span> for each <span>$k$</span>-point:<div>\[B_{Ψ,k} = \{ e_G : 1/2 |G + k|^2 ≤ E_\text{cut}\]</div></li><li>The <strong>potential</strong> or <strong>density basis</strong> <span>$B_\rho$</span>, consisting of all plane waves on which a potential needs to be known in order to be consistent with the union of all <span>$B_{Ψ,k}$</span> for all <span>$k$</span>. In practice we do not take the smallest possible set of wave vectors <span>$G$</span> for this, but instead the smallest <em>cubic</em> grid, which satisfies this, i.e.<div>\[B_\rho = \{ e_G : 1/2 |G|_\text{max}^2 ≤ α E_\text{cut} \},\]</div>where a supersampling factor <span>$\alpha = 4$</span> is required to give a numerically exact result, since<div>\[B_\rho = \{ e_{G+G&#39;} : ∃k e_G, e_{G&#39;} ∈ B_{Ψ,k} \}.\]</div>The choice of using a cubic grid is done in order to be consistent with usual fast Fourier transform implementations, which work on cubic Fourier grids.</li><li>The <strong>XC basis</strong> <span>$B_\text{XC}$</span>, which is used for computing the application of the exchange-correlation potential operator to the density <span>$\rho$</span>, represented in the basis <span>$B_\rho$</span>, that is<div>\[B_\text{XC}  = \{e_G : 1/2 |G|_\text{max}^2 ≤ β E_\text{cut} \}.\]</div>Since the exchange-correlation potential might involve arbitrary powers of the density <span>$ρ$</span>, a numerically exact computation of the integral<div>\[\langle e_G | V_\text{XC}(ρ) e_{G&#39;} \rangle \qquad \text{with} \qquad e_G, e_{G&#39;} ∈ B_{Ψ,k}\]</div>requires the exchange-correlation supersampling factor <span>$\beta$</span> to be infinite. In practice, <span>$\beta =4$</span> is usually chosen, such that <span>$B_\text{XC} = B_\rho$</span>.</li></ul><h2><a class="nav-anchor" id="Real-space-grids-1" href="#Real-space-grids-1">Real-space grids</a></h2><p>Due to the Fourier-duality of reciprocal-space and real-space lattice, the above basis sets define corresponding real-space grids as well:</p><ul><li>The grid <span>$B_\rho^\ast$</span>, the <strong>potential integration grid</strong>, which is the grid used for convolutions of a potential with the discretized representation of a DFT orbital. It is simply the iFFT-dual real-space grid of <span>$B_\rho$</span>.</li><li>The grid <span>$B^\ast_\text{XC}$</span>, the <strong>exchange-correlation integration grid</strong>, i.e. the grid used for convolutions of the exchange-correlation functional terms with the density or derivatives of it. It is the iFFT-dual of <span>$B_\text{XC}$</span>.</li></ul><h2><a class="nav-anchor" id="Core-1" href="#Core-1">Core</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PlaneWaveBasis(lattice::Mat3{T}, grid_size::Vec3{I}, Ecut::Number, kpoints,
               kweights) where {T &lt;: Real, I &lt;: Integer}</code></pre><p>Create a plane-wave basis from a specification for the Fourier grid size and a kinetic energy cutoff to select the <span>$k$</span>-point-specific wave function basis <span>$B_{Ψ,k}$</span> in a way that the selected <span>$G$</span> wave vectors satisfy <span>$|G + k|^2/2 \leq Ecut$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = PlaneWaveBasis(TODO)</code></pre><p><strong>Arguments</strong></p><ul><li><code>lattice</code>:       Real-space lattice vectors in columns</li><li><code>grid_size</code>:     Size of the rectangular Fourier grid used as the                  density basis <span>$B_ρ$</span>. In each dimension <code>idim</code> the                  range of wave vectors (in integer coordinates) extends from                  <code>-ceil(Int, (grid_size[idim]-1) / 2)</code> up to                  <code>floor(Int, (grid_size[idim]-1) / 2)</code>. No optimisation is done                  on the size of the grid with respect to performing FFTs.</li><li><code>Ecut</code>:          Kinetic energy cutoff in Hartree</li><li><code>kpoints</code>:       List of <span>$k$</span>-Points in fractional coordinats</li><li><code>kweights</code>:      List of corresponding weights for the Brillouin-zone integration.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PlaneWaveBasis.jl#L34-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.set_kpoints!" href="#DFTK.set_kpoints!"><code>DFTK.set_kpoints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reset the kpoints of an existing Plane-wave basis and change the basis accordingly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PlaneWaveBasis.jl#L82-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.basis_ρ" href="#DFTK.basis_ρ"><code>DFTK.basis_ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return a generator producing the range of wave-vector coordinates contained in the Fourier grid <span>$B_ρ$</span> described by the plane-wave basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PlaneWaveBasis.jl#L107-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.G_to_r!" href="#DFTK.G_to_r!"><code>DFTK.G_to_r!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">G_to_r!(pw::PlaneWaveBasis, f_fourier, f_real[, basis_ρ])</code></pre><p>Perform an in-place FFT to translate between <code>f_fourier</code>, a fourier representation of a function using the wave vectors specified in <code>basis_ρ</code> and a representation on the real-space density grid <span>$B^∗_ρ$</span>. The function will destroy all data in <code>f_real</code>. If <code>basis_ρ</code> is absent, the full density grid <span>$B_ρ$</span> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PlaneWaveBasis.jl#L121-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.r_to_G!" href="#DFTK.r_to_G!"><code>DFTK.r_to_G!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">r_to_G!(pw::PlaneWaveBasis, f_real, f_fourier[, gcoords])</code></pre><p>Perform an in-place FFT to translate between <code>f_real</code>, a representation of a function on the real-space density grid <span>$B^∗_ρ$</span> and a fourier representation using the wave vectors specified in <code>gcoords</code>. If <code>gcoords</code> is less than the wave vectors required to exactly represent <code>f_real</code>, than this function implies a truncation. On call all data in <code>f_real</code> and <code>f_fourier</code> will be destroyed. If <code>gcoords</code> is absent, the full density grid <span>$B_ρ$</span> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PlaneWaveBasis.jl#L152-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PotLocal" href="#DFTK.PotLocal"><code>DFTK.PotLocal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Class for holding the values of a local potential, like the local part of a pseudopotential</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PotLocal.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PotNonLocal" href="#DFTK.PotNonLocal"><code>DFTK.PotNonLocal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PotNonLocal(pw::PlaneWaveBasis, positions, psps)</code></pre><p>Build a Kleinman-Bylander representation of the non-local potential term for the given <code>basis</code>. <code>positions</code> is a mapping from an identifier to a set of positions in fractional coordinates and <code>psps</code> is a mapping from the identifier to the pseudopotential object associated to this idendifier.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PotNonLocal.jl#L12-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.Kinetic" href="#DFTK.Kinetic"><code>DFTK.Kinetic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Kinetic energy operator in a plane-wave basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Kinetic.jl#L1-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.Hamiltonian" href="#DFTK.Hamiltonian"><code>DFTK.Hamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Hamiltonian(basis::PlaneWaveBasis; kinetic=Kinetic(basis), pot_local=nothing,
            pot_nonlocal=nothing, pot_hartree=nothing, pot_xc=nothing)</code></pre><p>Hamiltonian discretized in a plane-wave <code>basis</code>. Terms which are not specified (left as <code>nothing</code>) are ignored during application. If only a basis object is specified, a free-electron Hamiltonian is constructed. The <code>kinetic</code> <code>pot_local</code> and <code>pot_nonlocal</code> terms shall not contain a non-linearity in the density.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L11-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.apply_hamiltonian!" href="#DFTK.apply_hamiltonian!"><code>DFTK.apply_hamiltonian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_hamiltonian!(out, ham, ik, pot_hartree_values, pot_xc_values, in)</code></pre><p>Apply the <code>ik</code>-th <span>$k$</span>-Point block of a Hamiltonian using precomputed values for the non-linear Hartree and XC potential (in <code>pot_hartree_values</code> and <code>pot_xc_values</code>) on the real-space grid <span>$B_\rho^∗$</span> at the current density.</p><p>For this <code>kinetic</code> and <code>pot_nonlocal</code> are applied to <code>in</code> using <code>apply_fourier!</code>. The other terms are treated via a convolution on the density grid <span>$B_\rho^∗$</span>, that is the procedure</p><pre><code class="language-none"> X_k --pad--&gt; Y --IFFT--&gt; Y* --V--&gt; Y* --FFT--&gt; Y --trunc--&gt; X_k</code></pre><p>where</p><pre><code class="language-none">  pad      Zero padding
  FFT      fast-Fourier transform
  IFFT     inverse fast-Fourier transform
  trunc    Truncation to a smaller basis
  V        Apply potential elementwise using `apply_real!`</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L26-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.apply_fourier!" href="#DFTK.apply_fourier!"><code>DFTK.apply_fourier!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply a <span>$k$</span>-block of a Hamiltonian term in Fourier space</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.apply_real!" href="#DFTK.apply_real!"><code>DFTK.apply_real!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply a Hamiltonian term by computation on the real-space density grid <span>$B^∗_ρ$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L94-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.compute_potential!" href="#DFTK.compute_potential!"><code>DFTK.compute_potential!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the potential of a non-linear term (e.g. <code>pot_hartree</code> or <code>pot_xc</code>) on the real-space density grid <span>$B^∗_ρ$</span>, given a current density <code>ρ</code> in the density basis <span>$B_ρ$</span>. If the passed term is <code>nothing</code>, <code>nothing</code> is returned by the function as well, else an array of values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L100-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.empty_potential" href="#DFTK.empty_potential"><code>DFTK.empty_potential</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return an appropriately sized container for a potential term on the real-space grid <span>$B^∗_ρ$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Hamiltonian.jl#L108-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PreconditionerKinetic" href="#DFTK.PreconditionerKinetic"><code>DFTK.PreconditionerKinetic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Kinetic-energy based preconditioner.</p><p>Applies <span>$1 / (|k + G|^2 / 2 + α)$</span> to the vectors, when called with <code>ldiv!</code>. This attempts to dampen the high-kinetic energy parts of the Hamiltonian, thus making the Hamiltonian more well-conditioned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/Preconditioner.jl#L6-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.lobpcg" href="#IterativeSolvers.lobpcg"><code>IterativeSolvers.lobpcg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lobpcg(ham::Hamiltonian, pot_hartree_values, pot_xc_values, nev_per_kpoint::Int;
       guess=nothing, prec=nothing, tol=1e-6, maxiter=100, backend=:lobpcg_qr,
       kwargs...)</code></pre><p>Run the LOBPCG implementation from <code>backend</code> for each <span>$k$</span>-Point of the Hamiltonian <code>ham</code>, solving for the <code>nev_per_kpoint</code> smallest eigenvalues. Optionally a <code>guess</code> and a preconditioner <code>prec</code> can be used. <code>pot_hartree_values</code> and <code>pot_xc_values</code> are the precomputed values of the Hartee and XC term of the Hamiltonian on the grid <span>$B_ρ^∗$</span>. The <code>backend</code> parameters selects the LOBPCG implementation to use.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/lobpcg.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.lobpcg_qr" href="#DFTK.lobpcg_qr"><code>DFTK.lobpcg_qr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lobpcg_qr(A, X0; maxiter=100, prec=I, tol=20size(A,2)*eps(eltype(A)), largest=false)</code></pre><p>Naive LOBPCG for finding the largest eigenpairs of a Hermitian matrix <code>A</code> starting from a guess <code>X0</code> of as many guess vectors as eigenpairs are sought. Optionally a preconditioner <code>prec</code> may be employed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/lobpcg_qr.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.lobpcg_scipy" href="#DFTK.lobpcg_scipy"><code>DFTK.lobpcg_scipy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lobpcg_scipy(A, X0; prec=nothing, tol=nothing, largest=false, kwargs...)</code></pre><p>Call scipy&#39;s version of LOBPCG for finding the eigenpairs of a Hermitian matrix <code>A</code>. <code>X0</code> is the set of guess vectors, also determining the number of eigenpairs to be sought.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/lobpcg_scipy.jl#L3-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.lobpcg_itsolve" href="#DFTK.lobpcg_itsolve"><code>DFTK.lobpcg_itsolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lobpcg_itsolve(A, X0; prec=nothing, largest=false, kwargs...)</code></pre><p>Call the <code>lobpcg</code> version from the <code>IterativeSolvers</code> package passing through most arguments</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/lobpcg_itsolve.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.occupation_zero_temperature" href="#DFTK.occupation_zero_temperature"><code>DFTK.occupation_zero_temperature</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the occupation at zero temperature and without smearing for <code>n_elec</code> electrons and the bands <code>Psi</code> with associated <code>energies</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/occupation.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.self_consistent_field" href="#DFTK.self_consistent_field"><code>DFTK.self_consistent_field</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">self_consistent_field(ham::Hamiltonian, n_bands::Int, n_electrons::Int;
                      ρ=nothing, tol=1e-6, max_iter=100, algorithm=:scf_nlsolve,
                      lobpcg_prec=PreconditionerKinetic(ham, α=0.1))</code></pre><p>Run a self-consistent field iteration for the Hamiltonian <code>ham</code>, returning the self-consistnet density, Hartree potential values and XC potential values. <code>n_bands</code> selects the number of bands to be computed, <code>n_electrons</code> the number of electrons, <code>ρ</code> is the initial density, e.g. constructed via a SAD guess. <code>lobpcg_prec</code> specifies the preconditioner used in the LOBPCG algorithms used for diagonalisation. Possible <code>algorithm</code>s are <code>:scf_nlsolve</code> or <code>:scf_damped</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/self_consistent_field.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.scf_nlsolve" href="#DFTK.scf_nlsolve"><code>DFTK.scf_nlsolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>TODO docme</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/scf_nlsolve.jl#L3-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.scf_damped" href="#DFTK.scf_damped"><code>DFTK.scf_damped</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>TODO docme</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/scf_damped.jl#L1-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PspHgh" href="#DFTK.PspHgh"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PspHgh(Zion::Number, rloc::Number, cloc::Vector, rp::Vector, h::Vector;
       identifier=&quot;&quot;, description=&quot;&quot;)</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998). The required parameters are the ionic charge <code>Zion</code> (total charge - valence electrons), the range for the local Gaussian charge distribution <code>rloc</code>, the coefficients for the local part <code>cloc</code>, the projector radius <code>rp</code> (one per AM channel) and the non-local coupling coefficients between the projectors <code>h</code> (one matrix per AM channel).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PspHgh.jl#L13-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_projection_radial" href="#DFTK.eval_psp_projection_radial"><code>DFTK.eval_psp_projection_radial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_projection_radial(psp::PspHgh, i, l, qsq::Number)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal lattice point with modulus squared <code>qsq</code>. Compared to the expressions in the GTH and HGH papers, this expression misses a factor of 1/sqrt(Ω).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PspHgh.jl#L138-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_local_real" href="#DFTK.eval_psp_local_real"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space. The vector <code>r</code> should be given in cartesian coordinates.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PspHgh.jl#L120-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_local_fourier" href="#DFTK.eval_psp_local_fourier"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_local_fourier</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space. Computes &lt;e<em>G|Vloc|e</em>{G+ΔG}&gt; without taking into account the structure factor and the (4π / Ω) spherical Hankel transform prefactor. <code>ΔG</code> should be in cartesian coordinates.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/PspHgh.jl#L95-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.compute_density" href="#DFTK.compute_density"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_density(pw::PlaneWaveBasis, Psi::AbstractVector, occupation::AbstractVector;
                tolerance_orthonormality)</code></pre><p>Compute the density for a wave function <code>Psi</code> discretised on the plane-wave grid <code>pw</code>, where the individual k-Points are occupied according to <code>occupation</code>. <code>Psi</code> should be one coefficient matrix per k-Point. If <code>tolerance_orthonormality</code> is ≥ 0, some orthonormality properties are verified explicitly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/core/compute_density.jl#L1-L9">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.determine_grid_size" href="#DFTK.determine_grid_size"><code>DFTK.determine_grid_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">determine_grid_size(lattice, Ecut; kpoints=[[0,0,0]], supersampling=2)</code></pre><p>Determine the minimal grid size for the density fourier grid <span>$B_ρ$</span> subject to the kinetic energy cutoff <code>Ecut</code> for the wave function and a density  <code>supersampling</code> factor.</p><p>The function will determine the union of wave vectors <span>$G$</span> required to satisfy <span>$|G + k|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span> for all <span>$k$</span>-Points. The returned grid dimensions are the smallest cartesian box to incorporate these <span>$G$</span>.</p><p>For an exact representation of the density resulting from wave functions represented in the basis <span>$B_ρ = \{G : |G + k|^2/2 \leq Ecut\}$</span>, <code>supersampling</code> should be at least <code>2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/determine_grid_size.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.build_local_potential" href="#DFTK.build_local_potential"><code>DFTK.build_local_potential</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_local_potential(pw::PlaneWaveBasis, positions, generators;
                      compensating_background=true)</code></pre><p>Function generating a local potential on the real-space density grid <span>$B^∗_ρ$</span> defined by the plane-wave basis <code>pw</code>. The potential is generated by summing (in Fourier space) analytic contributions from all species involved in the lattice, followed by an iFFT. The lattice definition is taken implicitly from <code>pw</code>.</p><p>The contributions are defined by the two maps <code>positions</code> and <code>generators</code>. The former maps a set of keys, uniquely identifying the lattice species, to a list of fractional coordinates defining their real-space positions. The latter maps each identifier to a function <code>G -&gt; potential(G)</code>, which defines the potential value for this species at this reciprocal space position (also passed to this function in integer coordinates).   The parameter <code>compensating_background</code> (default true) determines whether the DC component will be automatically set to zero, which physically corresponds to including a compensating change background in the potential model.</p><p><strong>Examples</strong></p><p>Given an appropriate lattice and basis definition in <code>basis</code> one may build the local potential for an all-electron treatment of sodium chloride as such</p><pre><code class="language-julia-repl">julia&gt; build_local_potential(basis,
                             [:Na =&gt; [[0,0,0], [1/2,1/2,0], [1/2,0,1/2], [0,1/2,1/2]],
                              :Cl =&gt; [[0,1/2,0], [1/2,0,0], [0,0,1/2], [1/2,1/2,1/2]]],
                             [:Na =&gt; -11 / sum(abs2, basis.recip_lattice * G), :Cl =&gt; -17 / sum(abs2, recip_lattice * G)])</code></pre><p>since sodium has nuclear charge 11 and chlorine charge 17.</p><p>For crystals composed of only a single species, such as silicon, one can drop the mappings:</p><pre><code class="language-julia-repl">julia&gt; build_local_potential(basis, [[0,0,0], [1/8, 1/8, 1/8]], G -&gt; -12 / sum(abs2, basis.recip_lattice * G))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/build_local_potential.jl#L1-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.kblock_as_matrix" href="#DFTK.kblock_as_matrix"><code>DFTK.kblock_as_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute a <span>$k$</span>-Point block of an operator as a dense matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/kblock_as_matrix.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.load_psp" href="#DFTK.load_psp"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">load_psp(identifier; search_directory)</code></pre><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>search_directory</code> and by the <code>identifier</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/load_psp.jl#L7-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.guess_gaussian_sad" href="#DFTK.guess_gaussian_sad"><code>DFTK.guess_gaussian_sad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">guess_gaussian_sad(basis, positions, Znucls, [Zions])</code></pre><p>Build a superposition of atomic densities (SAD) guess density. The atoms/species are specified by the three dictionaries <code>positions</code>, <code>Znucls</code> and <code>Zions</code>. The first specifies the list of atom positions, <code>Znucls</code> is the corresponding nuclear charge and <code>Zions</code> the corresponding ionic charge (i.e. the charge left over when pseudopotentials have been taken into account).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/guess_gaussian_sad.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.guess_hcore" href="#DFTK.guess_hcore"><code>DFTK.guess_hcore</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Obtain a guess density form diagonalising the core Hamiltonian associated to <code>ham</code>, i.e. strip the non-linear parts. <code>compute_occupation</code> computes the occupation values, taking into account potential smearing. <code>lobpcg_prec</code> is a preconditioner for LOBPCG and <code>n_bands</code> the number of bands to compute.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mfherbst/DFTK.jl/blob/253586b085f16b4d3efb3ec4d533ad9d17abfc5a/src/utils/guess_hcore.jl#L1-L6">source</a></section><footer><hr/></footer></article></body></html>
