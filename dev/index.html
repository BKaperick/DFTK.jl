<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DFTK.jl</title><link rel="canonical" href="https://juliamolsim.github.io/DFTK.jl/stable/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DFTK.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Notations-and-conventions-1"><span>Notations and conventions</span></a></li><li><a class="tocitem" href="#Units-1"><span>Units</span></a></li><li><a class="tocitem" href="#Coordinates-1"><span>Coordinates</span></a></li><li><a class="tocitem" href="#Naming-conventions-1"><span>Naming conventions</span></a></li><li class="toplevel"><a class="tocitem" href="#Basic-datastructures-1"><span>Basic datastructures</span></a></li><li><a class="tocitem" href="#Model-1"><span>Model</span></a></li><li><a class="tocitem" href="#PlaneWaveBasis-1"><span>PlaneWaveBasis</span></a></li><li class="toplevel"><a class="tocitem" href="#Useful-formulas-1"><span>Useful formulas</span></a></li><li class="toplevel"><a class="tocitem" href="#Crystal-symmetries-1"><span>Crystal symmetries</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/index.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DFTK.jl:-The-density-functional-toolkit.-1"><a class="docs-heading-anchor" href="#DFTK.jl:-The-density-functional-toolkit.-1">DFTK.jl: The density-functional toolkit.</a><a class="docs-heading-anchor-permalink" href="#DFTK.jl:-The-density-functional-toolkit.-1" title="Permalink"></a></h1><p>DFTK is a <a href="https://julialang.org/">Julia</a> package for playing with plane-wave density-functional theory algorithms. In its basic formulation it solves periodic Kohn-Sham equations.</p><p>The following documentation is an overview of the structure of the code, and of the formalism used. It assumes basic familiarity with the concepts of plane-wave density functional theory. Users wanting to simply run computations or get an overview of features should look at <a href="https://dftk.org/tree/master/examples"><code>examples</code></a> directory in the main code.</p><p>In the following we will illustrate the concepts on the example of computing the LDA ground state of the Silicon crystal.</p><pre><code class="language-">using DFTK
using Plots
using LinearAlgebra

# 1. Define lattice and atomic positions
a = 10.26  # Silicon lattice constant in Bohr
lattice = a / 2 * [[0 1 1.];
                   [1 0 1.];
                   [1 1 0.]]

# Load HGH pseudopotential for Silicon
Si = ElementPsp(:Si, psp=load_psp(&quot;hgh/lda/Si-q4&quot;))

# Specify type and positions of atoms
atoms = [Si =&gt; [ones(3)/8, -ones(3)/8]]

# 2. Select model and basis
model = model_LDA(lattice, atoms)
kgrid = [4, 4, 4]  # k-Point grid (Regular Monkhorst-Pack grid)
Ecut = 15          # kinetic energy cutoff in Hartree
basis = PlaneWaveBasis(model, Ecut; kgrid=kgrid)

# 3. Run the SCF
scfres = self_consistent_field(basis, tol=1e-8);
nothing #hide</code></pre><h1 id="Notations-and-conventions-1"><a class="docs-heading-anchor" href="#Notations-and-conventions-1">Notations and conventions</a><a class="docs-heading-anchor-permalink" href="#Notations-and-conventions-1" title="Permalink"></a></h1><h2 id="Units-1"><a class="docs-heading-anchor" href="#Units-1">Units</a><a class="docs-heading-anchor-permalink" href="#Units-1" title="Permalink"></a></h2><p>DFTK uses atomic units throughout: lengths are in Bohr, energies in Hartree. In particular, <span>$\hbar = m_e = e = 4\pi \epsilon_0 = 1$</span>. In this convention the Schrödinger equation for the electron of the hydrogen atom is</p><div>\[i\partial_t \psi = -\frac 1 2 \Delta \psi - \frac 1 {|r|} \psi.\]</div><p>Useful conversion factors can be found in <code>DFTK.units</code>:</p><pre><code class="language-julia">DFTK.units.eV</code></pre><pre><code class="language-none">0.03674932248</code></pre><h2 id="Coordinates-1"><a class="docs-heading-anchor" href="#Coordinates-1">Coordinates</a><a class="docs-heading-anchor-permalink" href="#Coordinates-1" title="Permalink"></a></h2><p>Computations take place in the unit cell of a lattice defined by a <span>$3 × 3$</span> matrix (<code>model.lattice</code>) with lattice vectors as columns. Note that Julia stores matrices as column-major, so care has to be taken when interfacing with other libraries in row-major languages (e.g. Python). The reciprocal lattice <code>model.recip_lattice</code> (the lattice of Fourier coefficients of functions with the periodicity of the lattice) is defined by the matrix</p><div>\[B = 2\pi A^{-T} = 2π {A^{T}}^{-1}\]</div><p>where <span>$A$</span> is the unit cell.</p><pre><code class="language-julia">model.recip_lattice&#39; * model.lattice</code></pre><pre><code class="language-none">3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9} with indices SOneTo(3)×SOneTo(3):
 6.28319  0.0      0.0    
 0.0      6.28319  0.0    
 0.0      0.0      6.28319</code></pre><p>Vectors in real space are denoted by <span>$r$</span> if they reside inside the unit cell and by <span>$R$</span> for lattice vectors. Vectors in reciprocal space are analogously <span>$k$</span> (for vectors in the Brillouin zone) and <span>$G$</span> for vectors on the reciprocal lattice. Commonly <span>$q$</span> is used to refer to <span>$k + G$</span>. If not denoted otherwise the code uses <strong>reduced coordinates</strong> for these vectors. One switches to Cartesian coordinates by</p><div>\[x_\text{cart} = M x_\text{red}\]</div><p>where <span>$M$</span> is either <code>model.lattice</code> (for real-space vectors) or <code>model.recip_lattice</code> (for reciprocal-space vectors). A useful relationship is</p><div>\[b_\text{cart} \cdot a_\text{cart}=2\pi b_\text{red} \cdot a_\text{red}\]</div><p>if <span>$a$</span> and <span>$b$</span> are real-space and reciprocal-space vectors respectively. Other names for reduced coordinates are <strong>integer coordinates</strong> (usually for <span>$G$</span>-vectors) or <strong>fractional coordinates</strong> (usually for <span>$k$</span>-points).</p><h2 id="Naming-conventions-1"><a class="docs-heading-anchor" href="#Naming-conventions-1">Naming conventions</a><a class="docs-heading-anchor-permalink" href="#Naming-conventions-1" title="Permalink"></a></h2><p>DFTK liberally uses Unicode characters to represent Greek characters (e.g. ψ, ρ, ε...). Input them at the Julia REPL by their latex command and press &quot;TAB&quot;. For all major editors there are <a href="https://github.com/JuliaEditorSupport/">great Julia plugins</a> offering easy support for such characters as well.</p><ul><li><strong>Reciprocal-space vectors:</strong> <span>$k$</span> for vectors in the Brillouin zone, <span>$G$</span> for vectors of the reciprocal lattice, <span>$q$</span> for general vectors</li><li><strong>Real-space vectors:</strong> <span>$R$</span> for lattice vectors, <span>$r$</span> and <span>$x$</span> are usually used for unit for vectors in the unit cell or general real-space vectors, respectively. This convention is, however, less consistently applied.</li><li><span>$\Omega$</span> is the unit cell, and <span>$|\Omega|$</span> (or sometimes just <span>$\Omega$</span>) is its volume.</li><li><span>$A$</span> are the real-space lattice vectors (<code>model.lattice</code>) and <span>$B$</span> the Brillouin zone lattice vectors (<code>model.recip_lattice</code>).</li><li>The <strong>Bloch waves</strong> are<div>\[\psi_{nk}(x) = e^{ik\cdot x} u_{nk}(x),\]</div>where <span>$n$</span> is the band index and <span>$k$</span> the <span>$k$</span>-point. In the code we sometimes use <span>$\psi$</span> and <span>$u$</span> interchangeably.</li><li><span>$\varepsilon$</span> are the <strong>eigenvaluesi</strong>, <span>$\varepsilon_F$</span> is the <strong>Fermi level</strong>.</li><li><span>$\rho$</span> is the <strong>density</strong>.</li><li>In the code we use <strong>normalized plane waves</strong>:<div>\[e_G(r) = \frac 1 {\sqrt{\Omega}} e^{i G \cdot r}.\]</div></li><li><span>$Y^l_m$</span> are the complex <strong>spherical harmonics</strong>, and <span>$Y_{lm}$</span> the real ones.</li><li><span>$j_l$</span> are the Bessel functions. In particular, <span>$j_{0}(x) = \frac{\sin x}{x}$</span>.</li></ul><h1 id="Basic-datastructures-1"><a class="docs-heading-anchor" href="#Basic-datastructures-1">Basic datastructures</a><a class="docs-heading-anchor-permalink" href="#Basic-datastructures-1" title="Permalink"></a></h1><h2 id="Model-1"><a class="docs-heading-anchor" href="#Model-1">Model</a><a class="docs-heading-anchor-permalink" href="#Model-1" title="Permalink"></a></h2><p>The physical model to be solved is defined by the <code>Model</code> datastructure. It contains the unit cell, number of electrons, atoms, type of spin polarization and temperature. Each atom has an atomic type (<code>Element</code>) specifying their number of valence electrons and the potential (or pseudopotential) it creates. The <code>Model</code> structure also contains the list of energy terms defining the model. These can be of the following types (for now), defined in the <a href="https://dftk.org/tree/master/src/terms"><code>src/terms</code></a> directory:</p><ul><li>Kinetic energy</li><li>Local potential energy, either given by analytic potentials or specified by the type of atoms.</li><li>Nonlocal potential energy, for norm-conserving pseudopotentials</li><li>Nuclei energies (eg Ewald or pseudopotential correction)</li><li>Hartree energy</li><li>Exchange-correlation energy</li><li>Power nonlinearities (useful for Gross-Pitaevskii type models)</li><li>Magnetic field energy</li><li>Entropy term</li></ul><p>By mixing and matching these terms, the user can create custom models. Convenience constructors are provided for commonly used models:</p><ul><li><code>model_DFT</code>: density-functional theory Hamiltonian using  any of the LDA or GGA functionals of the  <a href="https://tddft.org/programs/libxc/functionals/">libxc</a>  library.</li><li><code>model_LDA</code>: LDA Hamiltonian using the <a href="https://doi.org/10.1103/PhysRevB.54.1703">Teter parametrisation</a></li></ul><p>For the silicon example above the following terms were used<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>:</p><pre><code class="language-julia">typeof.(model.term_types)</code></pre><pre><code class="language-none">7-element Array{DataType,1}:
 Kinetic       
 AtomicLocal   
 AtomicNonlocal
 Ewald         
 PspCorrection 
 Hartree       
 Xc            </code></pre><p>DFTK computes energies for all terms of the model Hamiltonian. In the silicon example from above:</p><pre><code class="language-">display(scfres.energies)</code></pre><h2 id="PlaneWaveBasis-1"><a class="docs-heading-anchor" href="#PlaneWaveBasis-1">PlaneWaveBasis</a><a class="docs-heading-anchor-permalink" href="#PlaneWaveBasis-1" title="Permalink"></a></h2><p>The <code>PlaneWaveBasis</code> datastructure handles the discretization of a given <code>Model</code> in a plane-wave basis. As usual in plane-wave methods the discretization is twofold: Once the <span>$k$</span>-point grid, which determines how the Brillouin zone is sampled in the discrete basis and once the sampling of the reciprocal-space lattice, which is restricted to a finite set of plane waves. The former aspect is controlled by the <code>kgrid</code> agrument (or by an explicit list of <span>$k$</span>-points) and the latter is controlled by the cutoff energy parameter <code>Ecut</code>.</p><p>The periodic parts of Bloch waves are expanded in a set of normalized plane waves <span>$e_G$</span>:</p><div>\[\begin{aligned}
  \psi_{k}(x) &amp;= e^{i k \cdot x} u_{k}(x)\\
  &amp;= \sum_{G \in \mathcal R^{*}} c_{G}  e^{i  k \cdot  x} e_{G}(x)
\end{aligned}\]</div><p>where <span>$\mathcal R^*$</span> is the set of reciprocal lattice vectors. The <span>$c_{{G}}$</span> are <span>$\ell^{2}$</span>-normalized. The summation is truncated to a &quot;spherical&quot;, <span>$k$</span>-dependent basis set</p><div>\[  S_{k} = \left\{G \in \mathcal R^{*} \,\middle|\, \frac 1 2 |k+ G|^{2} \le E_\text{cut}\right\}\]</div><p>where <span>$E_\text{cut}$</span> is the cutoff energy.</p><p>Densities involve terms like <span>$|\psi_{k}|^{2} = |u_{k}|^{2}$</span> and therefore products <span>$e_{-{G}} e_{{G}&#39;}$</span> for <span>${G}, {G}&#39;$</span> in <span>$S_{k}$</span>. To represent these we use a &quot;cubic&quot;, <span>$k$</span>-independent basis set large enough to contain the set <span>$\{{G}-G&#39; \,|\, G, G&#39; \in S_{k}\}$</span>. We can obtain the coefficients of densities on the <span>$e_{G}$</span> basis by a convolution, which can be performed efficiently with FFTs (see <code>G_to_r</code> and <code>r_to_G</code> functions). Potentials are discretized on this same set.</p><p>The normalization conventions used in the code is that quantities stored in reciprocal space are coefficients in the <span>$e_{G}$</span> basis, and quantities stored in real space use real physical values. This means for instance that wavefunctions in the real space grid are normalized as <span>$\frac{|\Omega|}{N} \sum_{r} |\psi(r)|^{2} = 1$</span> where <span>$N$</span> is the number of grid points.</p><p>For example let us check the normalization of the first eigenfunction at the first <span>$k$</span>-Point in reciprocal space:</p><pre><code class="language-">ψtest = scfres.ψ[1][:, 1]
sum(abs2.(ψtest))</code></pre><p>We now perform an IFFT to get ψ in real space. The <span>$k$</span>-Point has to be passed because ψ is expressed on the <span>$k$</span>-dependent basis. Again the function is normalised:</p><pre><code class="language-">ψreal = G_to_r(basis, basis.kpoints[1], ψtest)
sum(abs2.(ψreal)) * model.unit_cell_volume / prod(basis.fft_size)</code></pre><p>The list of <span>$k$</span> points can be obtained with <code>basis.kpoints</code>.</p><pre><code class="language-">basis.kpoints</code></pre><p>The <span>$G$</span> vectors of the &quot;spherical&quot;, <span>$k$</span>-dependent grid can be obtained with <code>G_vectors(basis.kpoints[ik])</code> with an index <code>ik</code>:</p><pre><code class="language-">[length(G_vectors(k)) for k in basis.kpoints]</code></pre><pre><code class="language-">ik = 1
G_vectors(basis.kpoints[ik])[1:4]</code></pre><p>The list of <span>$G$</span> vectors (Fourier modes) of the &quot;cubic&quot;, <span>$k$</span>-independent basis set can be obtained with <code>G_vectors(basis)</code>.</p><pre><code class="language-">length(G_vectors(basis)), prod(basis.fft_size)</code></pre><pre><code class="language-">collect(G_vectors(basis))[1:4]</code></pre><p>Analogously the list of <span>$r$</span> vectors (real-space grid) can be obtained with <code>r_vectors(basis)</code>:</p><pre><code class="language-">length(r_vectors(basis))</code></pre><pre><code class="language-">collect(r_vectors(basis))[1:4]</code></pre><p>As seen above, wavefunctions are stored in an array <code>ψ</code> as <code>ψ[ik][iG, iband]</code> where <code>ik</code> is the index of the kpoint (in <code>basis.kpoints</code>), <code>iG</code> is the index of the plane wave (in <code>G_vectors(basis.kpoints[ik])</code>) and <code>iband</code> is the index of the band. Densities are usually stored in a special type, <code>RealFourierArray</code>, from which the representation in real and reciprocal space can be accessed using <code>ρ.real</code> and <code>ρ.fourier</code> respectively.</p><pre><code class="language-">rvecs = collect(r_vectors(basis))[:, 1, 1]  # slice along the x axis
x = [r[1] for r in rvecs]                   # only keep the x coordinate
plot(x, scfres.ρ.real[:, 1, 1], label=&quot;&quot;, xlabel=&quot;x&quot;, ylabel=&quot;ρ&quot;, marker=2)</code></pre><pre><code class="language-">G_energies = [sum(abs2.(model.recip_lattice * G)) ./ 2 for G in G_vectors(basis)][:]
scatter(G_energies, abs.(scfres.ρ.fourier[:]);
        yscale=:log10, ylims=(1e-12, 1), label=&quot;&quot;, xlabel=&quot;Energy&quot;, ylabel=&quot;|ρ|^2&quot;)</code></pre><p>(the density has no components on wavevectors above a certain energy, because the wavefunctions are limited to <span>$\frac 1 2|k+G|^2 ≤ E_{\rm cut}$</span>)</p><h1 id="Useful-formulas-1"><a class="docs-heading-anchor" href="#Useful-formulas-1">Useful formulas</a><a class="docs-heading-anchor-permalink" href="#Useful-formulas-1" title="Permalink"></a></h1><ul><li>The Fourier transform is</li></ul><div>\[\widehat{f}( q) = \int_{{\mathbb R}^{3}} e^{-i q \cdot  x} dx\]</div><ul><li>Plane wave expansion formula</li></ul><div>\[e^{i {q} \cdot {r}} =
     4 \pi \sum_{l = 0}^\infty \sum_{m = -l}^l
     i^l j_l(|q| |r|) Y_l^m(q/|q|) Y_l^{m\ast}(r/|r|)\]</div><ul><li>Spherical harmonics orthogonality</li></ul><div>\[   \int_{\mathbb{S}^2} Y_l^{m*}(r)Y_{l&#39;}^{m&#39;}(r) dr
     = \delta_{l,l&#39;} \delta_{m,m&#39;}\]</div><p>This also holds true for real spherical harmonics.</p><ul><li>Fourier transforms of centered functions: If</li></ul><p><span>$f({x}) = R(x) Y_l^m(x/|x|)$</span>, then</p><div>\[\begin{aligned}
  \hat f( q)
  &amp;= \int_{{\mathbb R}^3} R(x) Y_{l}^{m}(x/|x|) e^{-i {q} \cdot {x}} d{x} \\
  &amp;= \sum_{l = 0}^\infty 4 \pi i^l
  \sum_{m = -l}^l \int_{{\mathbb R}^3}
  R(x) j_{l&#39;}(|q| |x|)Y_{l&#39;}^{m&#39;}(-q/|q|) Y_{l}^{m}(x/|x|)
   Y_{l&#39;}^{m&#39;\ast}(x/|x|)
  d{x} \\
  &amp;= 4 \pi Y_{l}^{m}(-q/|q|) i^{l}
  \int_{{\mathbb R}^+} r^2 R(r) \ j_{l}(|q| r) dr
 \end{aligned}\]</div><p>This also holds true for real spherical harmonics.</p><h1 id="Crystal-symmetries-1"><a class="docs-heading-anchor" href="#Crystal-symmetries-1">Crystal symmetries</a><a class="docs-heading-anchor-permalink" href="#Crystal-symmetries-1" title="Permalink"></a></h1><p>In this discussion we will only describe the situation for a monoatomic crystal <span>$\mathcal C \subset \mathbb R^3$</span>, the extension being easy. A symmetry of the crystal is a real-space unitary matrix <span>$\tilde{S}$</span> and a real-space vector <span>$\tilde{τ}$</span> such that</p><div>\[\tilde{S} \mathcal{C} + \tilde{\tau} = \mathcal{C}.\]</div><p>The symmetries where <span>$\tilde S = 1$</span> and <span>$\tilde{τ}$</span> is a lattice vector are always assumed and ignored in the following.</p><p>We can define a corresponding unitary operator <span>${U} : L^2_\text{per} \to L^2_\text{per}$</span> with action</p><div>\[ (Uu)(x) = u\left( S^{-1} (x-\tau) \right),\]</div><p>where we set</p><div>\[\begin{aligned}
S &amp;= \tilde{S}^{-1}\\
\tau &amp;= -\tilde{S}^{-1}\tilde{\tau}.
\end{aligned}\]</div><p>This unitary operator acts on the Fourier coefficients of lattice-periodic functions as</p><div>\[(Uu)(G) = e^{-i G \cdot \tau} u(S^{-1} G)\]</div><p>and so</p><div>\[U (-i∇ + k) U^* = (-i∇ + Sk)\]</div><p>Furthermore, since the potential <span>$V$</span> is the sum over radial potentials centered at atoms, it is easily seen that <span>$U V U^* = V$</span>, i.e. that <span>$U$</span> and <span>$V$</span> commute.</p><p>It follows that if the Bloch wave <span>$ψ_k = e^{ik\cdot x} u_k$</span> is an eigenfunction of the Hamiltonian, then <span>$e^{i (Sk) \cdot x} (Uu_k)$</span> is also an eigenfunction, and so we can take</p><div>\[u_{Sk} = U u_k.\]</div><p>This is used to reduce the computations needed. For a uniform sampling of the Brillouin zone (the <em>reducible <span>$k$</span>-Points</em>), one can find a reduced set of <span>$k$</span>-Points (the <em>irreducible <span>$k$</span>-Points</em>) such that the eigenvectors at the reducible <span>$k$</span>-Points can be deduced from those at the irreducible <span>$k$</span>-Points.</p><pre><code class="language-">basis_irred = basis
scfres_irred = scfres
# Redo the same computation but disabling symmetry handling
basis_red = PlaneWaveBasis(model, Ecut; kgrid=kgrid, enable_bzmesh_symmetry=false)
scfres_red = self_consistent_field(basis_red, tol=1e-8)
(norm(scfres_irred.ρ.real - scfres_red.ρ.real),
 norm(values(scfres_irred.energies) .- values(scfres_red.energies)))</code></pre><p>The results are identical up to the convergence threshold, but compared to the first calculation on the top of the page, disabling symmetry leads to a substantially larger computational time, since more <span>$k$</span>-Points are explicitly treated:</p><pre><code class="language-">(length(basis_red.kpoints), length(basis_irred.kpoints))</code></pre><p>!!!note &quot;The <code>tol</code> argument in <code>self_consistent_field</code>&quot;     The <code>tol</code> argument to <code>self_consistent_field</code> is a convergence threshold     in the total energy, such that less agreement is found in the density.</p><p>To demonstrate the mapping, let us consider an example:</p><pre><code class="language-">ikpt_irred = 2 # pick an arbitrary kpoint in the irreducible BZ
kpt_irred_coord = basis_irred.kpoints[ikpt_irred].coordinate
basis_irred.ksymops[ikpt_irred]</code></pre><p>This is a list of all symmetries operations <span>$(S,\tau)$</span> that can be used to map this irreducible kpoint to reducible kpoints. Let&#39;s pick the third symmetry operation of this <span>$k$</span>-Point and check.</p><pre><code class="language-">S, τ = basis_irred.ksymops[ikpt_irred][3]
kpt_red_coord = S * basis_irred.kpoints[ikpt_irred].coordinate
ikpt_red = findfirst(kcoord -&gt; kcoord ≈ kpt_red_coord,
                     [k.coordinate for k in basis_red.kpoints])
(scfres_irred.eigenvalues[ikpt_irred], scfres_red.eigenvalues[ikpt_red])</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>If you are not familiar with Julia syntax, this is equivalent to <code>[typeof(t) for t in model.term_types]</code>.</li></ul></section></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 27 May 2020 19:21">Wednesday 27 May 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
