"""
    build_local_potential(pw::PlaneWaveBasis, positions, generators;
                          compensating_background=true)

Function generating a local potential on the real-space density grid ``B^∗_ρ``
defined by the plane-wave basis `pw`. The potential is generated by summing
(in Fourier space) analytic contributions from all species involved in the
lattice, followed by an iFFT. The lattice definition is taken implicitly from `pw`.

The contributions are defined by the two maps `positions` and `generators`.
The former maps a set of keys, uniquely identifying the lattice species,
to a list of fractional coordinates defining their real-space positions.
The latter maps each identifier to a function `G -> potential(G)`, which
defines the potential value for this species at this reciprocal space position
(also passed to this function in integer coordinates).  
The parameter `compensating_background` (default true) determines whether the DC component
will be automatically set to zero, which physically corresponds to including
a compensating change background in the potential model.

# Examples
Given an appropriate lattice and basis definition in `basis` one may build
the local potential for an all-electron treatment of sodium chloride as such
```julia-repl
julia> build_local_potential(basis,
                             [:Na => [[0,0,0], [1/2,1/2,0], [1/2,0,1/2], [0,1/2,1/2]],
                              :Cl => [[0,1/2,0], [1/2,0,0], [0,0,1/2], [1/2,1/2,1/2]]],
                             [:Na => -11 / sum(abs2, basis.recip_lattice * G), :Cl => -17 / sum(abs2, recip_lattice * G)])
```
since sodium has nuclear charge 11 and chlorine charge 17.

For crystals composed of only a single species, such as silicon, one can drop the mappings:
```julia-repl
julia> build_local_potential(basis, [[0,0,0], [1/8, 1/8, 1/8]], G -> -12 / sum(abs2, basis.recip_lattice * G))
```
"""
function build_local_potential(pw::PlaneWaveBasis, positions, generators;
                               compensating_background=true)
    T = eltype(pw.lattice)
    positions = Dict{Any, Vector{Vec3{T}}}(positions)
    generators = Dict{Any, Function}(generators)
    species = keys(positions)  # The list of all species

    for spec in species
        if !haskey(generators, spec)
            throw(ArgumentError("No generator found for species $(string(spec))." *
                                "Please check that the generator specification contains" *
                                " a key for each species defined in the positions " *
                                "parameter."))
        end
    end

    # Get the values in the plane-wave basis set (Fourier space)
    values_fourier = map(basis_ρ(pw)) do G
        sum(
            4π / pw.unit_cell_volume  # Prefactor spherical Hankel transform
            * generators[spec](G)     # Potential data for wave vector G
            * cis(2π * dot(G, r))     # Structure factor
            for spec in species
            for r in positions[spec]
        )
    end
    if compensating_background
        values_fourier[pw.idx_DC] = 0
    end

    values_real = similar(values_fourier, Complex{T}, size(pw.FFT)...)
    G_to_r!(pw, values_fourier, values_real)
    if maximum(imag(values_real)) > 100 * eps(T)
        throw(ArgumentError("Expected potential on the real-space grid to be entirely" *
                            " real-valued, but the present potential gives rise to a " *
                            "maximal imaginary entry of $(maximum(imag(values_real)))."))
    end
    PotLocal(real(values_real))
end
function build_local_potential(basis::PlaneWaveBasis, positions::Vector{V},
                               generator::Function;
                               compensating_background=true) where V <: Vector
    build_local_potential(basis, Dict(:species => positions), Dict(:species => generator),
                          compensating_background=compensating_background)
end
